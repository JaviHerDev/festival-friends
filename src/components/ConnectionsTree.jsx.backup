import { useState, useEffect, useCallback, useMemo } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  Panel,
  useReactFlow,
  ReactFlowProvider,
  Handle,
  Position,
} from 'reactflow';
import 'reactflow/dist/style.css';
import '../styles/reactflow.css';
import { 
  UserIcon, 
  MapPinIcon, 
  MagnifyingGlassIcon,
  ArrowPathIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  PlusIcon,
  MinusIcon,
  HandRaisedIcon,
  ArrowsPointingOutIcon,
  ArrowsPointingInIcon,
  EyeIcon,
  EyeSlashIcon,
  FunnelIcon,
  ViewColumnsIcon,
  CpuChipIcon,
  SparklesIcon,
  BoltIcon,
  HeartIcon,
  StarIcon
} from '@heroicons/react/24/outline';
import useStore from '../store/useStore.js';

// Enhanced User Node Component
  const UserNode = ({ data, selected, id }) => {
    const { user } = useStore();
    const isCurrentUser = user?.id === id;
  
  return (
                            <div 
                          className={`
                            relative group cursor-pointer transition-all duration-300
                            ${selected ? 'scale-110' : ''}
                            ${isCurrentUser ? 'ring-2 ring-blue-500 ring-opacity-50' : ''}
                          `}
    >
      {/* Glow effect for current user */}
      {isCurrentUser && (
        <div className="absolute -inset-2 bg-blue-500/20 rounded-2xl blur-xl animate-pulse" />
      )}
      
      {/* Glassmorphism Card */}
                                <div className={`
                            relative overflow-hidden rounded-2xl p-4 min-w-[220px] max-w-[280px]
                            bg-gradient-to-br from-slate-800/95 to-slate-900/95
                            border border-slate-700/50 backdrop-blur-sm
                            shadow-2xl transition-all duration-300
                            ${selected ? 'border-purple-500/50 shadow-purple-500/25' : ''}
                            ${isCurrentUser ? 'border-blue-500/50 shadow-blue-500/25' : ''}
                            ${data.level === 0 ? 'border-green-500/50 shadow-green-500/25' : ''}
                            
                          `}>
        
        
        
        
        {/* User Info */}
        <div className="relative z-10 flex items-start space-x-4">
          {/* Enhanced Avatar */}
          <div className="relative flex-shrink-0">
            <div className={`
              w-16 h-16 rounded-full flex items-center justify-center text-white font-bold text-xl
              ${data.avatar_url ? 'bg-cover bg-center' : 'bg-gradient-to-br from-blue-500 via-purple-600 to-pink-600'}
              shadow-lg border-2 border-slate-600/50
                                          transition-all duration-300
            `}
            style={data.avatar_url ? { backgroundImage: `url(${data.avatar_url})` } : {}}
            >
              {!data.avatar_url && (data.name?.charAt(0) || 'U').toUpperCase()}
            </div>
            
            
            
                          {/* Connection Count Badge */}
              {data.connectionCount > 0 && (
                <div className="absolute -top-1 -left-1 w-6 h-6 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full border-2 border-white flex items-center justify-center shadow-lg">
                  <span className="text-xs font-bold text-white">{data.connectionCount}</span>
                </div>
              )}
            
            
          </div>
          
          {/* User Details */}
          <div className="flex-1 min-w-0">
                                            <div className="flex items-center justify-between mb-1">
                                  <h3 className="text-base font-bold text-white truncate">
                                    {data.name}
                                  </h3>
                                  {data.level !== undefined && (
                                    <div className="flex-shrink-0 ml-2 px-2 py-1 bg-slate-700/50 rounded-full">
                                      <span className="text-xs font-medium text-slate-300">
                                        Nivel {data.level}
                                      </span>
                                    </div>
                                  )}
                                </div>
            {data.nickname && (
              <p className="text-sm text-slate-300 truncate mb-2">
                @{data.nickname}
              </p>
            )}
            {data.city && (
              <div className="flex items-center space-x-2 mb-2">
                <MapPinIcon className="w-4 h-4 text-red-400" />
                <span className="text-sm text-slate-400 truncate">{data.city}</span>
              </div>
            )}
            
            {/* Connection strength indicator */}
            <div className="flex items-center space-x-1">
              <div className="flex space-x-1">
                {[...Array(5)].map((_, i) => (
                  <div
                    key={i}
                    className={`w-1 h-3 rounded-full transition-all duration-300 ${
                      i < Math.min(data.connectionCount, 5) 
                        ? 'bg-gradient-to-t from-purple-400 to-pink-400' 
                        : 'bg-slate-600'
                    }`}
                  />
                ))}
              </div>
              <span className="text-xs text-slate-500 ml-2">
                {data.connectionCount} conexiones
              </span>
            </div>
          </div>
        </div>
        
                                  
                        </div>
                        
                        {/* Invisible handles for connections - multiple positions for shortest path */}
                        <Handle
                          type="target"
                          position={Position.Left}
                          className="opacity-0"
                        />
                        <Handle
                          type="target"
                          position={Position.Top}
                          className="opacity-0"
                        />
                        <Handle
                          type="target"
                          position={Position.Bottom}
                          className="opacity-0"
                        />
                        <Handle
                          type="source"
                          position={Position.Right}
                          className="opacity-0"
                        />
                        <Handle
                          type="source"
                          position={Position.Top}
                          className="opacity-0"
                        />
                        <Handle
                          type="source"
                          position={Position.Bottom}
                          className="opacity-0"
                        />
                      </div>
                    );
                  };



// React Flow Wrapper Component
const ReactFlowWrapper = ({ 
  nodes, 
  edges, 
  onNodeClick, 
  onEdgeClick, 
  showBackground, 
  showMiniMap, 
  showControls,
  nodeTypes 
}) => {
  const { fitView } = useReactFlow();

  // Auto-fit view when data changes
  useEffect(() => {
    if (nodes.length > 0) {
      setTimeout(() => {
        fitView({ padding: 0.3, duration: 1000 });
      }, 100);
    }
  }, [nodes, fitView]);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      nodeTypes={nodeTypes}
      onNodeClick={onNodeClick}
      onEdgeClick={onEdgeClick}
      fitView
      fitViewOptions={{ padding: 0.3 }}
      minZoom={0.05}
      maxZoom={4}
      defaultViewport={{ x: 0, y: 0, zoom: 1 }}
      proOptions={{ hideAttribution: true }}
      className="bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900"
      connectionLineStyle={{ stroke: '#8b5cf6', strokeWidth: 2.5, strokeDasharray: '10,5' }}
      connectionLineType="straight"
      snapToGrid={true}
      snapGrid={[15, 15]}
    >
      {showBackground && (
        <Background
          variant="dots"
          gap={30}
          size={2}
          color="#475569"
          className="opacity-20"
        />
      )}
      
      {showControls && (
        <Controls
          showZoom={true}
          showFitView={true}
          showInteractive={true}
          className="bg-slate-800/90 border border-slate-700/50 rounded-xl backdrop-blur-sm"
        />
      )}
      
      {showMiniMap && (
        <MiniMap
          nodeColor="#8b5cf6"
          nodeStrokeColor="#ffffff"
          nodeStrokeWidth={3}
          maskColor="rgba(0, 0, 0, 0.6)"
          className="bg-slate-800/90 border border-slate-700/50 rounded-xl backdrop-blur-sm"
        />
      )}
      
      {/* Enhanced Panel */}
      <Panel position="top-left" className="bg-slate-800/90 border border-slate-700/50 rounded-xl p-3 backdrop-blur-sm">
        <div className="flex items-center space-x-4 text-sm text-white">
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 bg-blue-500 rounded-full animate-pulse" />
            <span>Nodos: {nodes.length}</span>
          </div>
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 bg-purple-500 rounded-full animate-pulse" />
            <span>Conexiones: {edges.length}</span>
          </div>
        </div>
      </Panel>
    </ReactFlow>
  );
};

const ConnectionsTree = () => {
  const { users, loadUsers, user, userProfile, setProfileModalOpen, isLoading: authLoading, forceAuthCheck } = useStore();
  const [searchTerm, setSearchTerm] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [selectedUser, setSelectedUser] = useState(null);
  const [showControls, setShowControls] = useState(true);
  const [showMiniMap, setShowMiniMap] = useState(true);
  const [showBackground, setShowBackground] = useState(true);
      const [layoutType, setLayoutType] = useState('radial'); // 'radial', 'grid'

  // Detect mobile device
  const isMobile = typeof window !== 'undefined' && window.innerWidth < 768;

  useEffect(() => {
    const initUsers = async () => {
      if (user && !authLoading) {
        await loadUsers();
        setIsLoading(false);
      } else if (!user && !authLoading) {
        await forceAuthCheck();
      }
    };
    
    initUsers();
  }, [user, authLoading, forceAuthCheck]);

  // Enhanced layout function
  const createLayout = useCallback((users, layoutType) => {
    if (!users.length) return { nodes: [], edges: [] };

    const nodes = [];
    const edges = [];

    if (layoutType === 'radial') {
      // Radial tree layout - much better for visualizing connections
      const centerX = 800; // Center of the canvas
      const centerY = 400; // Center of the canvas
      const baseRadius = 120; // Distance between levels
      const angleStep = 0.8; // Radians between nodes in same level
      
      // Group users by level (based on nexus_person)
      const levels = new Map();
      const processed = new Set();
      
      // Find root users (no nexus_person) - Level 0
      const rootUsers = users.filter(u => !u.nexus_person);
      levels.set(0, rootUsers);
      rootUsers.forEach(u => processed.add(u.id));
      
      // Build levels dynamically
      let currentLevel = 1;
      while (processed.size < users.length && currentLevel < 10) {
        const currentLevelUsers = users.filter(u => 
          !processed.has(u.id) && 
          u.nexus_person && 
          processed.has(users.find(p => p.name === u.nexus_person)?.id)
        );
        
        if (currentLevelUsers.length > 0) {
          levels.set(currentLevel, currentLevelUsers);
          currentLevelUsers.forEach(u => processed.add(u.id));
        }
        currentLevel++;
      }
      
      // Position nodes in radial layout
      levels.forEach((levelUsers, level) => {
        const radius = level * baseRadius;
        
        if (level === 0) {
          // Root level: place in center or small circle
          if (levelUsers.length === 1) {
            // Single root user in center
            nodes.push({
              id: levelUsers[0].id,
              type: 'userNode',
              position: { x: centerX, y: centerY },
              data: {
                ...levelUsers[0],
                connectionCount: users.filter(u => u.nexus_person === levelUsers[0].name).length,
                level: level
              }
            });
          } else {
            // Multiple root users in small circle
            levelUsers.forEach((user, index) => {
              const angle = (index / levelUsers.length) * 2 * Math.PI;
              const x = centerX + Math.cos(angle) * 50;
              const y = centerY + Math.sin(angle) * 50;
              
              nodes.push({
                id: user.id,
                type: 'userNode',
                position: { x, y },
                data: {
                  ...user,
                  connectionCount: users.filter(u => u.nexus_person === user.name).length,
                  level: level
                }
              });
            });
          }
        } else {
          // Child levels: position based on parent connections
          const parentGroups = new Map();
          
          // Group children by their parent
          levelUsers.forEach((user) => {
            const parentUser = users.find(u => u.name === user.nexus_person);
            if (parentUser) {
              const parentId = parentUser.id;
              if (!parentGroups.has(parentId)) {
                parentGroups.set(parentId, []);
              }
              parentGroups.get(parentId).push(user);
            }
          });
          
          // Position children around their parents
          parentGroups.forEach((children, parentId) => {
            const parentNode = nodes.find(n => n.id === parentId);
            if (parentNode) {
              const parentAngle = Math.atan2(parentNode.position.y - centerY, parentNode.position.x - centerX);
              
              children.forEach((child, childIndex) => {
                // Calculate angle for this child
                const totalChildren = children.length;
                const angleOffset = (childIndex - (totalChildren - 1) / 2) * angleStep;
                const childAngle = parentAngle + angleOffset;
                
                // Position child at the current level radius
                const x = centerX + Math.cos(childAngle) * radius;
                const y = centerY + Math.sin(childAngle) * radius;
                
                nodes.push({
                  id: child.id,
                  type: 'userNode',
                  position: { x, y },
                  data: {
                    ...child,
                    connectionCount: users.filter(u => u.nexus_person === child.name).length,
                    level: level
                  }
                });
              });
            }
          });
        }
      });
      
            // Create edges for radial layout with curved connections
      const connectionPairs = [];
      users.forEach(user => {
        if (user.nexus_person) {
          const sourceUser = users.find(u => u.name === user.nexus_person);
          if (sourceUser) {
            connectionPairs.push({ source: sourceUser, target: user });
          }
        }
      });
      
      // Create edges with smooth curves for radial layout
      let connectionIndex = 0;
      connectionPairs.forEach((pair) => {
        const sourceNode = nodes.find(n => n.id === pair.source.id);
        const targetNode = nodes.find(n => n.id === pair.target.id);
        
        if (sourceNode && targetNode) {
          // Use smoothstep for better curved connections in radial view
          const lineType = 'smoothstep';
            
          // Generate unique color based on connection
          const colors = [
            '#8b5cf6', '#ec4899', '#10b981', '#f59e0b', '#3b82f6', 
            '#f97316', '#06b6d4', '#84cc16', '#a855f7', '#ef4444',
            '#14b8a6', '#f43f5e', '#6366f1', '#06b6d4', '#84cc16'
          ];
          const uniqueColor = colors[connectionIndex % colors.length];
          
          edges.push({
            id: `${pair.source.id}-${pair.target.id}`,
            source: pair.source.id,
            target: pair.target.id,
            type: lineType,
            animated: true,
            style: {
              stroke: uniqueColor,
              strokeWidth: 2.5,
              strokeDasharray: '10,5'
            },
            markerEnd: {
              type: 'arrowclosed',
              color: uniqueColor,
              width: 12,
              height: 12,
              strokeWidth: 1.5
            }
          });
          
          connectionIndex++;
        }
      });
    }
    } else if (layoutType === 'grid') {
      // Grid layout for better distribution
      const nodeWidth = 280;
      const nodeHeight = 120;
      const padding = 50;
      const cols = Math.ceil(Math.sqrt(users.length));
      const rows = Math.ceil(users.length / cols);
      
      users.forEach((user, index) => {
        const col = index % cols;
        const row = Math.floor(index / cols);
        const x = col * (nodeWidth + padding) + 100;
        const y = row * (nodeHeight + padding) + 100;
        
        nodes.push({
          id: user.id,
          type: 'userNode',
          position: { x, y },
          data: {
          ...user,
            connectionCount: users.filter(u => u.nexus_person === user.name).length
          }
        });
      });
      
      // Create edges for grid layout with advanced distribution
      const connectionPairs = [];
      users.forEach(user => {
        if (user.nexus_person) {
          const sourceUser = users.find(u => u.name === user.nexus_person);
          if (sourceUser) {
            connectionPairs.push({ source: sourceUser, target: user });
          }
        }
      });
      
      // Group connections by source to prevent overlapping
      const connectionGroups = {};
      connectionPairs.forEach(pair => {
        const sourceId = pair.source.id;
        if (!connectionGroups[sourceId]) {
          connectionGroups[sourceId] = [];
        }
        connectionGroups[sourceId].push(pair);
      });
      
      // Create edges with layered positioning for grid
      let connectionIndex = 0;
      Object.entries(connectionGroups).forEach(([sourceId, pairs]) => {
        pairs.forEach((pair, pairIndex) => {
          const sourceNode = nodes.find(n => n.id === pair.source.id);
          const targetNode = nodes.find(n => n.id === pair.target.id);
          
          if (sourceNode && targetNode) {
            // Calculate direction and apply offset
            const dx = targetNode.position.x - sourceNode.position.x;
            const dy = targetNode.position.y - sourceNode.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Normalize direction
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            
            // Perpendicular vector for offset
            const perpX = -normalizedDy;
            const perpY = normalizedDx;
            
            // Apply offset based on connection index
            const baseOffset = 25;
            const layerOffset = pairIndex * 12;
            const totalOffset = baseOffset + layerOffset;
            
            const offsetX = perpX * totalOffset;
            const offsetY = perpY * totalOffset;
            
            // Color variants for different connections
            const colorVariants = [
              '#8b5cf6', '#ec4899', '#10b981', '#f59e0b', '#3b82f6', '#f97316', '#06b6d4'
            ];
            
            const colorIndex = connectionIndex % colorVariants.length;
            const color = colorVariants[colorIndex];
            
            edges.push({
              id: `${pair.source.id}-${pair.target.id}`,
              source: pair.source.id,
              target: pair.target.id,
              type: 'smoothstep',
              animated: true,
              style: {
                stroke: color,
                strokeWidth: 3,
                strokeDasharray: '10,5'
              },
              markerEnd: {
                type: 'arrowclosed',
                color: color,
                width: 16,
                height: 16,
                strokeWidth: 2
              }
            });
            
            connectionIndex++;
          }
        });
      });
    }

    return {
      nodes, 
      edges 
    };
  }, [layoutType]);

  // Build nodes and edges with enhanced layout
  const { nodes, edges } = useMemo(() => {
    return createLayout(users, layoutType);
  }, [users, createLayout]);

  // Filter nodes based on search
  const filteredNodes = useMemo(() => {
    if (!searchTerm) return nodes;
    
    const searchLower = searchTerm.toLowerCase();
    return nodes.filter(node => 
      node.data.name?.toLowerCase().includes(searchLower) ||
      node.data.nickname?.toLowerCase().includes(searchLower) ||
      node.data.city?.toLowerCase().includes(searchLower) ||
      node.data.nexus_person?.toLowerCase().includes(searchLower)
    );
  }, [nodes, searchTerm]);

  const filteredEdges = useMemo(() => {
    if (!searchTerm) return edges;
    
    const visibleNodeIds = new Set(filteredNodes.map(n => n.id));
    return edges.filter(edge => 
      visibleNodeIds.has(edge.source) && visibleNodeIds.has(edge.target)
    );
  }, [edges, filteredNodes, searchTerm]);

  // Node types
  const nodeTypes = useMemo(() => ({
    userNode: UserNode
  }), []);

  // Handle node selection
  const handleNodeClick = useCallback((event, node) => {
    if (node.type === 'userNode') {
      setSelectedUser(node.data);
    }
  }, []);

  // Handle edge click
  const handleEdgeClick = useCallback((event, edge) => {
    console.log('Edge clicked:', edge);
  }, []);

  // Center on current user
  const centerOnCurrentUser = useCallback(() => {
    if (user?.id) {
      const userNode = filteredNodes.find(n => n.id === user.id);
      if (userNode) {
        console.log('Centering on user:', user.id);
      }
    }
  }, [user, filteredNodes]);

  // Reset view
  const resetView = useCallback(() => {
    console.log('Resetting view');
  }, []);

  // Show loading while auth is being checked
  if (authLoading) {
    return (
      <div className="text-center py-12">
        <div className="animate-spin h-8 w-8 border-2 border-primary-600 border-t-transparent rounded-full mx-auto mb-4"></div>
        <p className="text-slate-300">Verificando autenticaci√≥n...</p>
      </div>
    );
  }

  // Show message if no user is authenticated
  if (!user) {
    return (
      <div className="text-center py-12">
        <div className="text-6xl mb-4">üîê</div>
        <h3 className="text-xl font-semibold text-white mb-2">
          Inicia sesi√≥n para ver el √°rbol de conexiones
        </h3>
        <p className="text-slate-500">
          Necesitas estar autenticado para acceder a esta funcionalidad
        </p>
      </div>
    );
  }

  // Show loading while userProfile is being loaded
  if (user && !userProfile && !authLoading) {
    return (
      <div className="text-center py-12">
        <div className="animate-spin h-8 w-8 border-2 border-primary-600 border-t-transparent rounded-full mx-auto mb-4"></div>
        <p className="text-slate-300">Cargando tu perfil...</p>
      </div>
    );
  }

  // Show message if user doesn't have nexus_person configured
  if (user && userProfile && !userProfile.nexus_person) {
    return (
      <div className="text-center py-12">
        <div className="text-6xl mb-4">üîó</div>
        <h3 className="text-xl font-semibold text-white mb-4">
          Necesitas configurar tu Persona Nexo
        </h3>
        <div className="max-w-2xl mx-auto space-y-4">
          <p className="text-slate-300 text-lg">
            Para poder visualizarte en el √°rbol de conexiones, necesitas especificar qui√©n te introdujo en la comunidad.
          </p>
          
          <div className="bg-slate-800/50 border border-slate-700/50 rounded-lg p-6 text-left">
            <h4 className="text-lg font-semibold text-white mb-3">üìã ¬øC√≥mo configurar tu Persona Nexo?</h4>
            <ol className="space-y-3 text-slate-300">
              <li className="flex items-start space-x-3">
                <span className="bg-primary-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold flex-shrink-0 mt-0.5">1</span>
                <span>Ve a tu <strong>perfil de usuario</strong> haciendo clic en tu avatar en la esquina superior derecha</span>
              </li>
              <li className="flex items-start space-x-3">
                <span className="bg-primary-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold flex-shrink-0 mt-0.5">2</span>
                <span>Busca la secci√≥n <strong>"Persona Nexo"</strong> en tu perfil</span>
              </li>
              <li className="flex items-start space-x-3">
                <span className="bg-primary-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold flex-shrink-0 mt-0.5">3</span>
                <span>Escribe el <strong>nombre o nickname</strong> de la persona que te introdujo en Festival&Friends</span>
              </li>
              <li className="flex items-start space-x-3">
                <span className="bg-primary-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold flex-shrink-0 mt-0.5">4</span>
                <span>Guarda los cambios y <strong>vuelve aqu√≠</strong> para ver tu posici√≥n en el √°rbol</span>
              </li>
            </ol>
          </div>

          <div className="bg-yellow-900/20 border border-yellow-700/50 rounded-lg p-4">
            <p className="text-yellow-300 text-sm">
              üí° <strong>Consejo:</strong> Si no recuerdas qui√©n te introdujo o eres uno de los fundadores, 
              puedes escribir tu propio nombre o "Fundador" en el campo de Persona Nexo.
            </p>
          </div>

          <div className="bg-blue-900/20 border border-blue-700/50 rounded-lg p-4">
            <p className="text-blue-300 text-sm">
              üå≥ <strong>¬øQu√© es el √Årbol de Conexiones?</strong> Es un esquema visual que muestra las relaciones 
              entre miembros basadas en el campo "Persona Nexo". Es solo informativo y no permite editar las conexiones.
            </p>
          </div>

          <div className="flex justify-center pt-4">
            <button
              onClick={() => setProfileModalOpen(true)}
              className="px-6 py-3 bg-primary-600 hover:bg-primary-700 text-white font-semibold rounded-lg transition-colors border border-primary-500 hover:border-primary-400 flex items-center space-x-2"
            >
              <UserIcon className="h-5 w-5" />
              <span>Ir a Mi Perfil</span>
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
        <div className="flex-1">
          <h1 className="text-2xl sm:text-3xl font-bold text-white mb-2">
          üå≥ √Årbol de Conexiones
          </h1>
          <p className="text-slate-400 text-sm sm:text-base">
            Visualizaci√≥n de las relaciones basadas en "Persona Nexo"
          </p>
          <div className="mt-2 p-3 bg-blue-900/20 border border-blue-700/50 rounded-lg">
            <p className="text-blue-300 text-sm">
              üí° <strong>Nota:</strong> Este es un esquema visual que muestra las relaciones existentes. 
              Las conexiones se basan en el campo "Persona Nexo" de cada usuario y no se pueden editar directamente aqu√≠.
            </p>
          </div>
        </div>
      </div>

      {/* Enhanced Controls */}
      <div className="flex flex-col lg:flex-row gap-4">
        <div className="relative flex-1">
          <MagnifyingGlassIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-slate-400" />
          <input
            type="text"
            placeholder="Buscar por nombre, nickname, ciudad o nexo..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="input pl-10 w-full"
          />
        </div>
        
        <div className="flex flex-wrap gap-2">
          <button
            onClick={() => {
              setSearchTerm('');
              resetView();
            }}
            className="px-4 py-2 bg-slate-700/50 hover:bg-slate-600/50 text-white font-medium rounded-lg transition-colors border border-slate-600/50 hover:border-slate-500/50 flex items-center space-x-2"
          >
            <ArrowPathIcon className="h-4 w-4" />
            <span>Reiniciar</span>
          </button>
          
          <button
            onClick={() => {
              setIsLoading(true);
              loadUsers().then(() => setIsLoading(false));
            }}
            className="px-4 py-2 bg-primary-600/50 hover:bg-primary-600/70 text-white font-medium rounded-lg transition-colors border border-primary-500/50 hover:border-primary-400/50 flex items-center space-x-2"
          >
            <ArrowPathIcon className="h-4 w-4" />
            <span>Recargar</span>
          </button>

          {/* Mobile Controls Toggle */}
          {isMobile && (
            <button
              onClick={() => setShowControls(!showControls)}
              className="px-4 py-2 bg-purple-600/50 hover:bg-purple-600/70 text-white font-medium rounded-lg transition-colors border border-purple-500/50 hover:border-purple-400/50 flex items-center space-x-2"
            >
              <HandRaisedIcon className="h-4 w-4" />
              <span>Controles</span>
            </button>
          )}
        </div>
      </div>

      {/* Enhanced Controls */}
      {showControls && (
        <div className="flex flex-wrap gap-2 p-4 bg-slate-800/50 rounded-lg border border-slate-700/50">
          <div className="flex items-center space-x-2">
            <span className="text-sm text-slate-300">Layout:</span>
            <select
              value={layoutType}
              onChange={(e) => setLayoutType(e.target.value)}
              className="px-3 py-1 bg-slate-700/50 border border-slate-600/50 rounded text-white text-sm"
            >
                              <option value="radial">Radial (Por Defecto)</option>
              <option value="grid">Cuadr√≠cula</option>
            </select>
          </div>
        
        <button
            onClick={centerOnCurrentUser}
            className="px-3 py-1 bg-yellow-600/50 hover:bg-yellow-600/70 text-white text-sm font-medium rounded-lg transition-colors border border-yellow-500/50 hover:border-yellow-400/50 flex items-center space-x-2"
          >
            <UserIcon className="h-4 w-4" />
            <span>Mi Posici√≥n</span>
        </button>
        
          <button
            onClick={() => setShowMiniMap(!showMiniMap)}
            className="px-3 py-1 bg-green-600/50 hover:bg-green-600/70 text-white text-sm font-medium rounded-lg transition-colors border border-green-500/50 hover:border-green-400/50 flex items-center space-x-2"
          >
            <ViewColumnsIcon className="h-4 w-4" />
            <span>{showMiniMap ? 'Ocultar' : 'Mostrar'} Mapa</span>
          </button>
          
          <button
            onClick={() => setShowBackground(!showBackground)}
            className="px-3 py-1 bg-blue-600/50 hover:bg-blue-600/70 text-white text-sm font-medium rounded-lg transition-colors border border-blue-500/50 hover:border-blue-400/50 flex items-center space-x-2"
          >
            <SparklesIcon className="h-4 w-4" />
            <span>{showBackground ? 'Ocultar' : 'Mostrar'} Fondo</span>
          </button>
        </div>
      )}

      {/* Loading State */}
      {isLoading && (
        <div className="text-center py-12">
          <div className="animate-spin h-8 w-8 border-2 border-primary-600 border-t-transparent rounded-full mx-auto mb-4"></div>
          <p className="text-slate-300">Cargando conexiones...</p>
        </div>
      )}

      {/* Empty State */}
      {!isLoading && filteredNodes.length === 0 && (
        <div className="text-center py-12">
          <div className="text-6xl mb-4">üå≥</div>
          <h3 className="text-xl font-semibold text-white mb-2">
            {searchTerm ? 'No se encontraron conexiones' : 'No hay conexiones a√∫n'}
          </h3>
          <p className="text-slate-500">
            {searchTerm 
              ? 'Prueba con otros t√©rminos de b√∫squeda'
              : 'Los usuarios aparecer√°n aqu√≠ cuando se conecten entre s√≠'
            }
          </p>
        </div>
      )}

      {/* React Flow Container */}
      {!isLoading && filteredNodes.length > 0 && (
        <div className="bg-slate-900/50 border border-slate-700/50 rounded-lg overflow-hidden">
          <div className="p-4 border-b border-slate-700/50">
            <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
              <div>
                <h2 className="text-lg font-semibold text-white">
                    Esquema Visual de Relaciones
                </h2>
                <p className="text-sm text-slate-400">
                    <span className="hidden md:inline">Arrastra para mover, rueda para hacer zoom, haz clic en los nodos para ver detalles</span>
                    <span className="md:hidden">Toca y arrastra para mover, pellizca para hacer zoom, toca los nodos para ver detalles</span>
                </p>
              </div>
              
              <div className="flex items-center space-x-2 text-sm text-slate-400">
                <div className="flex items-center space-x-1">
                  <div className="w-3 h-3 bg-blue-500 rounded-full animate-pulse"></div>
                  <span>Tu posici√≥n</span>
            </div>
                <div className="flex items-center space-x-1">
                  <div className="w-3 h-3 bg-purple-500 rounded-full animate-pulse"></div>
                  <span>Seleccionado</span>
          </div>
                <div className="flex items-center space-x-1">
                  <div className="w-3 h-3 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full animate-pulse"></div>
                  <span>Conexiones</span>
                  </div>
                  </div>
                  </div>
                </div>
          
          <div className="w-full h-[700px] md:h-[800px]">
            <ReactFlowProvider>
              <ReactFlowWrapper
                nodes={filteredNodes}
                edges={filteredEdges}
                onNodeClick={handleNodeClick}
                onEdgeClick={handleEdgeClick}
                showBackground={showBackground}
                showMiniMap={showMiniMap}
                showControls={showControls}
                nodeTypes={nodeTypes}
              />
            </ReactFlowProvider>
              </div>
            </div>
          )}
          
      {/* Selected User Details */}
      {selectedUser && (
        <div className="bg-slate-800/50 border border-slate-700/50 rounded-lg p-4">
          <h3 className="text-lg font-semibold text-white mb-3">
            üë§ Detalles del Usuario Seleccionado
          </h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <p className="text-sm text-slate-400">Nombre</p>
              <p className="text-white font-medium">{selectedUser.name}</p>
            </div>
            {selectedUser.nickname && (
              <div>
                <p className="text-sm text-slate-400">Nickname</p>
                <p className="text-white font-medium">@{selectedUser.nickname}</p>
                </div>
            )}
            {selectedUser.city && (
              <div>
                <p className="text-sm text-slate-400">Ciudad</p>
                <p className="text-white font-medium">{selectedUser.city}</p>
                  </div>
                )}
            {selectedUser.nexus_person && (
              <div>
                <p className="text-sm text-slate-400">Persona Nexo</p>
                <p className="text-white font-medium">{selectedUser.nexus_person}</p>
                <p className="text-xs text-slate-500 mt-1">Quien introdujo a este usuario</p>
              </div>
            )}
            <div>
              <p className="text-sm text-slate-400">Conexiones</p>
              <p className="text-white font-medium">{selectedUser.connectionCount || 0}</p>
              <p className="text-xs text-slate-500 mt-1">Usuarios que este usuario ha introducido</p>
            </div>
          </div>
          
          <div className="mt-4 p-3 bg-slate-700/30 border border-slate-600/50 rounded-lg">
            <p className="text-slate-300 text-sm">
              üí° Para editar la "Persona Nexo", ve al perfil del usuario y modifica el campo correspondiente.
            </p>
          </div>
        </div>
      )}

      {/* Enhanced Stats */}
      {!isLoading && filteredNodes.length > 0 && (
        <div className="mt-8">
          <h3 className="text-lg font-semibold text-white mb-4 text-center">
            üìä Estad√≠sticas del Esquema
          </h3>
          <div className="grid grid-cols-1 sm:grid-cols-4 gap-4">
            <div className="card text-center">
              <div className="text-2xl text-primary-400 mb-2">üë•</div>
              <div className="text-2xl font-bold">{users.length}</div>
              <div className="text-sm text-slate-500">Total Miembros</div>
            </div>
            
            <div className="card text-center">
              <div className="text-2xl text-purple-400 mb-2">üîó</div>
              <div className="text-2xl font-bold">{edges.length}</div>
              <div className="text-sm text-slate-500">Relaciones</div>
            </div>

            <div className="card text-center">
              <div className="text-2xl text-green-400 mb-2">üå±</div>
              <div className="text-2xl font-bold">
                {users.filter(u => !u.nexus_person).length}
              </div>
              <div className="text-sm text-slate-500">Usuarios Ra√≠z</div>
            </div>

            <div className="card text-center">
              <div className="text-2xl text-yellow-400 mb-2">üìä</div>
              <div className="text-2xl font-bold">
                {Math.round((edges.length / Math.max(users.length - 1, 1)) * 100)}%
              </div>
              <div className="text-sm text-slate-500">Cobertura</div>
            </div>
          </div>
          
          <div className="mt-6 p-4 bg-slate-800/50 border border-slate-700/50 rounded-lg">
            <h4 className="text-md font-semibold text-white mb-2">‚ÑπÔ∏è Informaci√≥n del Esquema</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-slate-300">
              <div>
                <p><strong>‚Ä¢ Nodos Azules:</strong> Usuarios de la comunidad</p>
                <p><strong>‚Ä¢ Nodos P√∫rpura-Rosa:</strong> Puntos de conexi√≥n visual</p>
                <p><strong>‚Ä¢ L√≠neas Animadas:</strong> Relaciones basadas en "Persona Nexo"</p>
                <p><strong>‚Ä¢ Layout Radial:</strong> Vista circular optimizada para conexiones</p>
              </div>
              <div>
                <p><strong>‚Ä¢ Punto Verde:</strong> Tu posici√≥n actual</p>
                <p><strong>‚Ä¢ Badge P√∫rpura:</strong> N√∫mero de usuarios introducidos</p>
                <p><strong>‚Ä¢ Solo Visual:</strong> Las conexiones no se pueden editar aqu√≠</p>
                <p><strong>‚Ä¢ Zoom:</strong> Usa rueda del rat√≥n para ajustar vista</p>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ConnectionsTree; 